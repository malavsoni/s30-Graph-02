// Time Complexity :
// Space Complexity :
function minMalwareSpread(graph: number[][], initial: number[]): number {
  // Create Groups and color them
  let color = 0;
  let colorGroup: number[] = Array.from({ length: graph.length });
  colorGroup.fill(-1);

  // Create Color Group
  // e.g 1->2->3  4->5
  //    [0, 0, 0, 1, 1]
  for (let i = 0; i < graph.length; i++) {
    if (colorGroup[i] == -1) {
      dfs(graph, colorGroup, i, color);
      color += 1;
    }
  }

  let nodesByColor: number[] = Array.from({ length: color });
  nodesByColor.fill(0);
  // Based on the color, count the number of nodes in the group.
  for (let idx = 0; idx < colorGroup.length; idx++) {
    nodesByColor[colorGroup[idx]]++;
  }

  let infectedNodesByColor: number[] = Array.from({ length: color });
  // Based on the color, count the number of infected nodes in the group.
  infectedNodesByColor.fill(0);
  for (let idx = 0; idx < initial.length; idx++) {
    infectedNodesByColor[colorGroup[initial[idx]]] += 1;
  }

  console.log(colorGroup);
  console.log(nodesByColor);
  console.log(infectedNodesByColor);

  let result = Number.MIN_SAFE_INTEGER;
  for (const infected of initial) {
    let colorOfInfected = colorGroup[infected];
    if (infectedNodesByColor[colorOfInfected] == 1) {
      console.log("Color " + colorOfInfected + " of infected " + infected);
      console.log("Size of infected " + nodesByColor[colorOfInfected]);
      if (result == Number.MIN_SAFE_INTEGER) result = infected;
      else if (
        nodesByColor[colorOfInfected] > nodesByColor[colorGroup[result]]
      ) {
        result = infected;
      } else if (
        nodesByColor[colorOfInfected] == nodesByColor[colorGroup[result]]
      ) {
        result = Math.min(result, infected);
      }
    }
  }

  if (result == Number.MIN_SAFE_INTEGER) {
    result = Math.min(...initial);
  }

  return result;
}

function dfs(
  graph: number[][],
  colorGroup: number[],
  i: number,
  color: number
) {
  if (colorGroup[i] != -1) {
    return;
  }

  colorGroup[i] = color;
  for (let j = 0; j < graph[i].length; j++) {
    if (i == j) continue;
    if (graph[i][j] == 1) {
      // If the nodes are connected color it with same color
      dfs(graph, colorGroup, j, color);
    }
  }
}

describe("924. Minimize Malware Spread", () => {
  it("Happy Path - 01", () => {
    expect(
      minMalwareSpread(
        [
          [1, 1, 0],
          [1, 1, 0],
          [0, 0, 1],
        ],
        [0, 1]
      )
    ).toEqual(0);
  });

  it("Failed Testcase - 01", () => {
    expect(
      minMalwareSpread(
        [
          [1, 0, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 1, 1],
          [0, 0, 1, 1],
        ],
        [3, 1]
      )
    ).toEqual(3);
  });
});
